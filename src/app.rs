//! Application lifecycle management.

mod controller;
mod stage;

pub use controller::*;
pub use stage::*;

use std::{
    collections::HashMap,
    fmt,
    sync::{Arc, Mutex, MutexGuard, RwLock},
    time::Instant,
};

use winit::{
    application::ApplicationHandler,
    event::WindowEvent,
    event_loop::{ActiveEventLoop, EventLoop},
    window::{Window, WindowId},
};

use crate::{
    input::{Action, ActionHandler},
    render::{RenderState, TimeStamp},
};

pub struct Rivik<A: Action> {
    init: Option<Box<dyn FnOnce(RivikController<A>)>>,
    windows: RwLock<HashMap<WindowId, Arc<Window>>>,
    stages: RwLock<HashMap<WindowId, Arc<Mutex<dyn Stage<A>>>>>,
    input: ActionHandler<A>,
    sim_time: TimeStamp,
    timestep: f32,
    prev_frametime: Option<Instant>,
    render_state: RenderState<u32, ()>,
}

impl<A: Action> Rivik<A> {
    pub fn run(init: impl FnOnce(RivikController<A>) + 'static) {
        let event_loop = EventLoop::new().unwrap();
        let mut app = Self {
            init: Some(Box::new(init)),
            windows: Default::default(),
            stages: Default::default(),
            input: ActionHandler::new(),
            sim_time: TimeStamp::default(),
            timestep: 1.0 / 1.0,
            prev_frametime: None,
            render_state: RenderState::new(/*timestep*/ 0.0),
        };
        event_loop.run_app(&mut app).unwrap();
    }

    fn controller<'a>(&'a mut self, event_loop: &'a ActiveEventLoop) -> RivikController<'a, A> {
        RivikController {
            rivik: self,
            event_loop,
        }
    }

    fn stage(&self, id: &WindowId) -> Option<Arc<Mutex<dyn Stage<A>>>> {
        let stage = {
            let stages = self.stages.read().unwrap();
            Arc::clone(stages.get(id)?)
        };
        Some(stage)
    }
}

impl<A: Action> ApplicationHandler for Rivik<A> {
    fn resumed(&mut self, event_loop: &ActiveEventLoop) {
        log::info!("Starting Rivik Engine");
        event_loop.set_control_flow(winit::event_loop::ControlFlow::Poll);
        (self.init.take().unwrap())(self.controller(event_loop));
    }

    fn window_event(
        &mut self,
        event_loop: &winit::event_loop::ActiveEventLoop,
        window_id: WindowId,
        event: WindowEvent,
    ) {
        // quick overview of how the gameloop should operate.
        // Time is generated by the game simulation in tick()
        // it pushes the current timestamp forward.
        // When we call render() it will check the dt since the last frame
        // and move the rendertimestamp forward by that much. (should always be behind the tick()
        // timestamp) We then feed that timestamp into the renderer as well as a way to record
        // render state (positions mostly) and the previous frame's render state. The renderer
        // SHOULD then interpolate between previous and current states using the timestamps.

        match &event {
            WindowEvent::CloseRequested => {
                let _ = self.windows.write().unwrap().remove(&window_id).unwrap();
                let _ = self.stages.write().unwrap().remove(&window_id).unwrap();
                if self.stages.read().unwrap().len() == 0 {
                    event_loop.exit();
                }
            }
            WindowEvent::RedrawRequested => {
                let time = Instant::now();
                let p_time = self.prev_frametime.unwrap_or_else(|| Instant::now());
                let dt = (time - p_time).as_secs_f32();
                self.prev_frametime = Some(time);

                log::error!("====== dt: {dt}");
                log::error!(" - sim_time: \t{}", *self.sim_time);
                log::error!(" - vis_time: \t{}", self.render_state.timestamp());

                let catchup = (*self.sim_time - self.render_state.timestamp()) as f32;
                log::error!(" - catchup:  \t{}", catchup);

                if catchup < self.timestep / 2.0 {
                    log::error!("=== TICK");
                    self.stage(&window_id)
                        .unwrap()
                        .lock()
                        .unwrap()
                        .tick(&mut self.input, self.timestep);
                    self.sim_time.tick(self.timestep);
                    log::error!(" - sim_time: \t{}", *self.sim_time);
                }

                // assume a range vis_time..sim_time mapped to 0..1
                // we need to figure out where vis_time+dt is
                let s = dt as f64 / (*self.sim_time - self.render_state.timestamp());

                self.stage(&window_id).unwrap().lock().unwrap().render(s as f32);
                self.render_state.tick(dt);
                log::error!(" - vis_time: \t{}", self.render_state.timestamp());

                // Try to render as fast as possible
                self.windows
                    .read()
                    .unwrap()
                    .get(&window_id)
                    .unwrap()
                    .request_redraw();
            }
            _ => {}
        }
        self.input.handle_winit(&event);
    }
}
